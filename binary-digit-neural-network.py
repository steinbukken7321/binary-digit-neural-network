# -*- coding: utf-8 -*-
"""Rede Neural p/ binarios [NN].ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KXXRomBgdcCw2V6yMu21rqDCizALBn1N

1. verificar taxa de aprendizado adequada ✔
2. verificar número de épocas adequada ✔
3. criar txt com dados de entrada ✔
4. criar predição após o treino com txt criado ✔
5. verificar resultados ✔
6. conferir funções e verificar se estão corretas com base na matemática ✔ (perda e acuracia relacionadas)

# **<font color="orange">1. Implementação das bibliotecas e do banco de dados</font>**

Nessa etapa iremos implementar as bibliotecas necessárias e o banco de dados a ser utilizado.

### <font color="cyan">1.1 Banco de dados e bibliotecas</font>
"""

import math
import random
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
import ipywidgets as widgets
from IPython.display import display, clear_output

# Definindo as representações binárias dos números de 0 a 9
num_0 = [
    [0, 1, 1, 1, 1, 0],
    [1, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 1],
    [0, 1, 1, 1, 1, 0]
]

num_1 = [
    [0, 0, 1, 1, 0, 0],
    [0, 1, 0, 1, 0, 0],
    [0, 0, 0, 1, 0, 0],
    [0, 0, 0, 1, 0, 0],
    [0, 1, 1, 1, 1, 0]
]

num_2 = [
    [0, 0, 1, 1, 0, 0],
    [0, 1, 0, 0, 1, 0],
    [0, 0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0, 0],
    [0, 1, 1, 1, 1, 0]
]

num_3 = [
    [0, 1, 1, 1, 1, 0],
    [1, 0, 0, 0, 0, 1],
    [0, 0, 1, 1, 1, 0],
    [1, 0, 0, 0, 0, 1],
    [0, 1, 1, 1, 1, 0]
]

num_4 = [
    [1, 0, 0, 0, 1, 0],
    [1, 0, 0, 0, 1, 0],
    [1, 1, 1, 1, 1, 1],
    [0, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 1, 0]
]

num_5 = [
    [0, 1, 1, 1, 1, 0],
    [0, 1, 0, 0, 0, 0],
    [0, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 1, 0],
    [0, 1, 1, 1, 0, 0]
]

num_6 = [
    [0, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 0, 0],
    [1, 1, 1, 1, 1, 0],
    [1, 0, 0, 0, 0, 1],
    [0, 1, 1, 1, 1, 0]
]

num_7 = [
    [0, 1, 1, 1, 1, 0],
    [0, 0, 0, 0, 1, 0],
    [0, 0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0, 0],
    [0, 0, 1, 0, 0, 0]
]

num_8 = [
    [0, 1, 1, 1, 1, 0],
    [1, 0, 0, 0, 0, 1],
    [0, 1, 1, 1, 1, 0],
    [1, 0, 0, 0, 0, 1],
    [0, 1, 1, 1, 1, 0]
]

num_9 = [
    [0, 1, 1, 1, 1, 1],
    [0, 1, 0, 0, 0, 1],
    [0, 1, 1, 1, 1, 1],
    [0, 0, 0, 0, 0, 1],
    [0, 1, 1, 1, 1, 1]
]

# Criando as entradas
x = [np.array(num_0), np.array(num_1),
     np.array(num_2), np.array(num_3),
     np.array(num_4), np.array(num_5),
     np.array(num_6), np.array(num_7),
     np.array(num_8), np.array(num_9)]
print(np.array(num_0))

# Criando os rótulos
y = np.eye(10)
print(y)

# Definindo as cores personalizadas para o colormap
custom_cmap = ListedColormap(['black', 'yellow'])  # Preto para o fundo, amarelo para os pixels

# Função para atualizar a imagem com base no número
def atualizar_imagem(numero_binario):
    img = x[numero_binario]
    plt.imshow(img, cmap=custom_cmap, vmin=0, vmax=1)
    plt.title(f"Número {numero_binario} na lista de dados para treinamento")
    plt.axis('off')  # remove/adiciona os eixos
    plt.show()

# Criando a caixa de escolha do número a ser exibido
dropdown = widgets.Dropdown(
    options=[(f'Número {i}', i) for i in range(10)],
    value=0,
    description='Número:'
)

# Exibindo o widget e a imagem
widgets.interactive(atualizar_imagem, numero_binario=dropdown)

"""# **<font color="orange">2. Rede neural treinada pelo banco de dados</font>**

Nessa etapa iremos criar a rede neural, treinar a rede e criar uma função de dedução para que assim a rede consiga deduzir o resultado correto.

### <font color="cyan">2.1 Rede neural, feedfoward, backpropagation e resultados iniciais</font>
"""

# função de ativação sigmoid
def sigmoid(x):
    return 1 / (1 + np.exp(-x))

# função de feedforward
def f_forward(x, w1, w2):
    # assumindo que x é uma matriz 5x6
    x = x.reshape(-1)  # garantir que x seja um vetor
    z1 = np.dot(x, w1)
    a1 = sigmoid(z1)
    z2 = np.dot(a1, w2)
    a2 = sigmoid(z2)
    return a2

# inicialização dos pesos
def generate_wt(x, y):
    return np.random.randn(x, y)


def loss(out, Y):
    # Calcula a soma dos erros quadráticos
    squared_errors = np.square(out - Y)
    total_error = np.sum(squared_errors)
    # Calcula a média
    return 0.5 * total_error / len(Y)

# função de backpropagation
def back_prop(x, y, w1, w2, Learning_rate):
    # assumindo que x é uma matriz 5x6
    x = x.reshape(-1)  # garantir que x seja um vetor 1D
    z1 = np.dot(x, w1)
    a1 = sigmoid(z1)
    z2 = np.dot(a1, w2)
    a2 = sigmoid(z2)

    d2 = a2 - y
    d1 = np.multiply(np.dot(d2, w2.T), np.multiply(a1, 1 - a1))

# a = np.array([1, 2, 3])
# b = np.array([4, 5, 6])
# result = np.multiply(a, b)
# resultado é array([ 4, 10, 18])

    w1_adj = np.outer(x, d1)
    w2_adj = np.outer(a1, d2)

# u = np.array([1, 2, 3])
# v = np.array([4, 5])
# result = np.outer(u, v)
# resultado é
# array([[ 4,  5],
#        [ 8, 10],
#        [12, 15]])

    w1 -= Learning_rate * w1_adj
    w2 -= Learning_rate * w2_adj
    return w1, w2

# função de treinamento
def train(x, Y, w1, w2, Learning_rate, epochs):
    acc = []
    losss = []
    for j in range(epochs):
        l = []
        for i in range(len(x)):
            out = f_forward(x[i], w1, w2)
            l.append(loss(out, Y[i]))
            w1, w2 = back_prop(x[i], Y[i], w1, w2, Learning_rate)
        acc.append((1 - (sum(l) / len(x))) * 100)
        losss.append(sum(l) / len(x))
    return acc, losss, w1, w2

# função de predição
def predict(x, w1, w2):
    Out = f_forward(x, w1, w2)
    k = np.argmax(Out)
    print(f"A imagem é o número {k}.")
    plt.imshow(x.reshape(5, 6))  # garantindo que x possa ser remodelado para (5, 6)
    plt.show()

# inicializando os pesos
w1 = generate_wt(30, 5)
w2 = generate_wt(5, 10)

# calculando a perda inicial
initial_loss = np.mean([loss(f_forward(x[i], w1, w2), y[i]) for i in range(len(x))])
print(f"Initial Loss: {initial_loss}")

# calculando a acurácia inicial
initial_acc = np.mean([np.argmax(f_forward(x[i], w1, w2)) == np.argmax(y[i]) for i in range(len(x))]) * 100
print(f"Initial Accuracy: {initial_acc:.2f}%")

# treinando a rede
acc, losss, w1, w2 = train(x, y, w1, w2, Learning_rate = 0.02, epochs = 1000)

# print da perda final
final_loss = losss[-1]
print(f"Final Loss: {final_loss}")

# print da acurácia final
final_acc = acc[-1]
print(f"Final Accuracy: {final_acc:.2f}%")

# plotando a acurácia
plt.figure(figsize=(10, 5))
plt.plot(acc)
plt.ylabel('Accuracy')
plt.xlabel("Epochs")
plt.show()

# plotando a perda
plt.figure(figsize=(10, 5))
plt.plot(losss)
plt.ylabel('Loss')
plt.xlabel("Epochs")
plt.show()

"""# **<font color="orange">3. Verificação da taxa de aprendizado adequada</font>**

Nessa etapa iremos conferir diferentes resultados para diferentes taxas de aprendizado.

### <font color="cyan">3.1 Testes para a rede neural com diferente taxas de aprendizado</font>

"""

# diferentes valores de taxa de aprendizado
learning_rates = [0.001, 0.01, 0.02, 0.03, 0.1, 0.5]

# p/ armazenar os históricos de perdas e acurácias para cada taxa de aprendizado
all_losses = {}
all_accuracies = {}

# looping para testar diferentes valores de learning rates
for lr in learning_rates:
    # Inicializando os pesos novamente para cada taxa de aprendizado
    w1 = generate_wt(30, 5)
    w2 = generate_wt(5, 10)

    # Treinando a rede
    acc, losss, w1, w2 = train(x, y, w1, w2, Learning_rate=lr, epochs=1000)

    # Armazenando os históricos
    all_losses[lr] = losss
    all_accuracies[lr] = acc

## Plotando os gráficos de perda e acurácia para cada taxa de aprendizado

# resultados de acurácia
plt.figure(figsize=(10, 5))
for lr, acc in all_accuracies.items():
    plt.plot(acc, label=f'LR={lr}')
plt.xlabel('Epochs')
plt.ylabel('Accuracy (%)')
plt.title('Accuracy vs Epochs for Different Learning Rates')
plt.legend()
plt.grid(False) # True = on | False = off
plt.show()

# resultados de perda
plt.figure(figsize=(10, 5))
for lr, losss in all_losses.items():
    plt.plot(losss, label=f'LR={lr}')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.title('Loss vs Epochs for Different Learning Rates')
plt.legend()
plt.grid(False) # True = on | False = off
plt.show()

"""---

# **<font color="orange">4. Txt com dados de entrada</font>**

Nessa etapa iremos modificar os dados de entrada(sequência binárias) e testar a rede de diferentes formas.

### <font color="cyan">4.1 sequência aleatória</font>
### <font color="cyan">4.2 sequência objetiva (txt)</font>
"""

# Função para gerar uma sequência aleatória de dados, imprimir a imagem, imprimir a matriz e testar a rede neural
def gerar_e_testar(b):
    clear_output(wait=True)  # Limpar a saída anterior
    display(botao_teste)     # Reexibir o botão
    display(botao_aleatorio) # Reexibir o segundo botão
    numero_aleatorio = random.randint(0, 9)
    imagem = x[numero_aleatorio]
    print(f"Sequência gerada (Número {numero_aleatorio}):")
    print(imagem)
    predict(imagem, w1, w2)

# Função para gerar uma sequência aleatória não baseada nas entradas dos dados existentes
def gerar_sequencia_aleatoria(b):
    clear_output(wait=True)  # Limpar a saída anterior
    display(botao_teste)     # Reexibir o primeiro botão
    display(botao_aleatorio) # Reexibir o botão
    imagem_aleatoria = np.random.randint(2, size=(5, 6))  # Gera uma matriz 5x6 com valores aleatórios de 0 ou 1
    print("Sequência aleatória gerada:")
    print(imagem_aleatoria)
    predict(imagem_aleatoria, w1, w2)
    plt.show()


# Criando o botão para gerar e testar com dados existentes
botao_teste = widgets.Button(
    description='Gerar dado existente',
    disabled=False,
    button_style='',
    tooltip='Clique para gerar uma sequência aleatória e testar a rede neural',
    icon='check'
)

# Criando o botão para gerar uma sequência aleatória
botao_aleatorio = widgets.Button(
    description='Gerar dado Aleatório',
    disabled=False,
    button_style='',
    tooltip='Clique para gerar uma sequência aleatória não baseada nos dados existentes',
    icon='random'
)

# Definindo as ações dos botões
botao_teste.on_click(gerar_e_testar)
botao_aleatorio.on_click(gerar_sequencia_aleatoria)

# Exibindo os botões
display(botao_teste)
display(botao_aleatorio)

# Função para alterar múltiplos bits aleatórios em uma sequência binária existente
def alterar_bits_aleatorios(imagem, num_bits):
    imagem_alterada = imagem.copy()
    indices = random.sample(range(imagem_alterada.size), num_bits)
    for i in indices:
        imagem_alterada[i // imagem_alterada.shape[1], i % imagem_alterada.shape[1]] ^= 1
    return imagem_alterada

# Função para gerar uma sequência alterada, imprimir a imagem, imprimir a matriz e testar a rede neural
def gerar_e_testar_alterado(b):
    clear_output(wait=True)  # Limpar a saída anterior
    display(bits_box)
    display(botao_alterar)   # Reexibir o botão
    numero_aleatorio = random.randint(0, 9)
    imagem = x[numero_aleatorio]
    num_bits = int(bits_box.value)  # Obtém o número de bits da caixa de entrada
    imagem_alterada = alterar_bits_aleatorios(imagem, num_bits)
    print(f"Sequência original (Número {numero_aleatorio}):")
    print(imagem)
    print("Sequência alterada:")
    print(imagem_alterada)
    plt.imshow(imagem_alterada, cmap=custom_cmap, vmin=0, vmax=1)
    plt.axis('off')
    plt.show()
    predict(imagem_alterada, w1, w2)

# Criando a caixa de entrada para o número de bits a serem alterados
bits_box = widgets.IntText(
    value=1,
    description='Bits a alterar:',
    disabled=False
)

# Criando o botão para gerar e testar com uma sequência alterada
botao_alterar = widgets.Button(
    description='Gerar e Testar Rede',
    disabled=False,
    button_style='',
    tooltip='Clique para alterar bits aleatórios e testar a rede neural',
    icon='edit'
)

# Definindo a ação do botão
botao_alterar.on_click(gerar_e_testar_alterado)

# Exibindo a caixa de entrada e o botão
display(bits_box)
display(botao_alterar)

# Função para gerar uma sequência alterada manualmente, imprimir a imagem, imprimir a matriz e testar a rede neural
def gerar_e_testar_manual(b):
    clear_output(wait=True)  # Limpar a saída anterior
    display(control_panel)  # Reexibir o painel de controle
    display(botao_manual)  # Reexibir o botão de gerar e testar
    imagem_manual = np.array([bit.value for bit in bit_widgets]).reshape(5, 6).astype(int)
    print("Sequência manual:")
    print(imagem_manual)
    plt.imshow(imagem_manual, cmap=custom_cmap, vmin=0, vmax=1)
    plt.axis('off')
    plt.show()
    predict(imagem_manual, w1, w2)

# Função para definir todos os bits para 1
def set_all_ones(b):
    for bit in bit_widgets:
        bit.value = True

# Função para definir todos os bits para 0
def set_all_zeros(b):
    for bit in bit_widgets:
        bit.value = False

# Criando widgets para entrada manual de bits usando ToggleButton
bit_widgets = [widgets.ToggleButton(value=False, description='0', layout=widgets.Layout(width='50px', height='50px')) for i in range(30)]

# Função para alternar entre 0 e 1
def on_toggle_change(change):
    if change['new']:
        change['owner'].description = '1'
        change['owner'].value = True
    else:
        change['owner'].description = '0'
        change['owner'].value = False

for bit in bit_widgets:
    bit.observe(on_toggle_change, names='value')

# Organizando os widgets em uma grade 5x6 com maior espaçamento
bit_grid = widgets.GridBox(bit_widgets, layout=widgets.Layout(
    grid_template_columns="repeat(6, 60px)",
    grid_template_rows="repeat(5, 60px)",
    grid_gap="10px 10px"
))

# Criando os botões "ALL 1" e "ALL 0"
botao_all_1 = widgets.Button(
    description='ALL 1',
    disabled=False,
    button_style='',  # cor neutra
    tooltip='Definir todos os bits para 1',
    icon='check'
)

botao_all_0 = widgets.Button(
    description='ALL 0',
    disabled=False,
    button_style='',  # cor neutra
    tooltip='Definir todos os bits para 0',
    icon='times'
)

# Definindo as ações dos botões "ALL 1" e "ALL 0"
botao_all_1.on_click(set_all_ones)
botao_all_0.on_click(set_all_zeros)

# Criando o botão para gerar e testar com uma sequência manual
botao_manual = widgets.Button(
    description='Gerar e Testar Rede',
    disabled=False,
    button_style='',  # cor neutra
    tooltip='Clique para testar a rede neural com uma sequência manual',
    icon='edit'
)

# Definindo a ação do botão "Gerar e Testar Rede"
botao_manual.on_click(gerar_e_testar_manual)

# Organizando os botões "ALL 1" e "ALL 0" ao lado da grade de bits
control_panel = widgets.HBox([bit_grid, widgets.VBox([botao_all_1, botao_all_0])])

# Exibindo a grade de widgets de bits e o botão
display(control_panel)
display(botao_manual)